#!/usr/bin/env escript
%% -*- erlang -*-


%% @doc 
%%this escript demo shows how to use erlang to work with acrcloud api
%%it is loosely based on the audio.py python examples
%%ideally the various functions can be put in an erlang library which can be exposed through an api
%%it depends on the inets application and the ssl application so those have to be started first.
%%A different http client can be used instead of httpc  like gun,hackney  in an actual application if decided
%%
%% @end
%%%-------------------------------------------------------------------



%% Main entry point.
%%please fill in all required values in xxx with real values
%%to run make sure erlang is installed with support for openssl and run ./audio_erl
main(_) ->
	ok = start_apps(),
	Acr_Host = "api.acrcloud.com",
	Acr_Secret_key = "xxx",
	Acr_key = "xxx",
	Api_version = "1",
	Path_file = "xxx",%%file should be placed in current folder for testing for use with upload_audio.
	Bucket_name = "xxx",
	Audio_title = "xxx",
	Audio_id = "xxx",
	Data_type = "xxx",%%audio or fingerprint
	Custom_fields = [{fname,"fname"},{lname,"lname"}],%%first value of tuple should be atom,second value should be string
	%%upload_audio(Acr_Host,Acr_Secret_key,Acr_key,Api_version,Path_file,Bucket_name,Audio_title,Audio_id,Data_type,Custom_fields).
	%%update_audio(Acr_Host,Acr_Secret_key,Acr_key,Sig_version,Bucket_name,Audio_title,Acr_id,Audio_id,Custom_fields).
	%%delete_audio(Acr_Host,Acr_Secret_key,Acr_key,Sig_version,Acr_id).
	%%get_audios(Acr_Host,Acr_Secret_key,Acr_key,Sig_version,Bucket_name,"1").



%%for starting apps needed for application to work
start_apps()->
	{ok,_} = application:ensure_all_started(inets),
	{ok,_} = application:ensure_all_started(ssl),
	ok.

	
%% for signing
sign(String_to_sign,Access_secret)->
	String_binary = erlang:list_to_binary(String_to_sign),
	Access_binary = erlang:list_to_binary(Access_secret),
	Res = crypto:hmac(sha,Access_binary,String_binary),
	base64:encode_to_string(Res).


%%for creating a signature
create_signature(Http_method,Http_uri,Access_key,Access_secret,Sig_version,Timestamp)->
	String_to_sign = [Http_method,Http_uri,Access_key,Sig_version,Timestamp],
	String_to_sign_join = string:join(String_to_sign,"\n"),	
	sign(String_to_sign_join, Access_secret).


%%%for uploading audio
upload_audio(URl_host,Access_secret,Access_key,Sig_version,Path_file,Bucket_name,Title,Audio_id,Data_type,Custom_fields)->
	Http_method = "POST",
	Http_uri = "/v1/audios",
	Timestamp = erlang:integer_to_list(calendar:datetime_to_gregorian_seconds(calendar:universal_time())-62167219200),
	Signature = create_signature(Http_method,Http_uri,Access_key,Access_secret,Sig_version,Timestamp),
	{ok, Audio_binary} = file:read_file(Path_file),	
	Requrl = lists:append(["https://",URl_host,Http_uri]),
	Boundary = "AaB03xXcvfbghy65",
	Data = [{audio_id,Audio_id}, {title, Title},{bucket_name,Bucket_name},{data_type,Data_type}],
	[Key_accum_final,Value_accum_final] = create_custom_fields(Custom_fields),
	Data_send = lists:append([Data,Key_accum_final,Value_accum_final]),
	Body = format_multipart_formdata(Boundary,Data_send,[{audio_file, "audio_file", Audio_binary}]),
	ContentType = lists:concat(["multipart/form-data; boundary=", Boundary]),
	Headers = [
				{"Content-length", integer_to_list(size(Body))},{"access-key",Access_key},
				{"signature-version",Sig_version},{"signature",Signature},{"timestamp",Timestamp},{"Accept","*/*"}
			  ],
	Result = httpc:request(post, {Requrl, Headers,ContentType, Body}, [],  [{sync,true}]),
	result_to_terms(Result).


%%for getting audios for a particular bucket
get_audios(URl_host,Access_secret,Access_key,Sig_version,Bucket,Page)->
	Http_method = "GET",
	Http_uri = "/v1/audios",
	Timestamp = erlang:integer_to_list(calendar:datetime_to_gregorian_seconds(calendar:universal_time())-62167219200),
	Signature = create_signature(Http_method,Http_uri,Access_key,Access_secret,Sig_version,Timestamp),
	Headers = [{"access-key",Access_key},{"signature-version",Sig_version},{"signature",Signature},{"timestamp",Timestamp},{"Accept","*/*"}],
	Query_string_escape = lists:append([edoc_lib:escape_uri("bucket_name"),"=",edoc_lib:escape_uri(Bucket),"&",edoc_lib:escape_uri("page"),"=",edoc_lib:escape_uri(Page)]),
	Requrl = lists:append(["https://",URl_host,Http_uri,"?",Query_string_escape]),
	Result = httpc:request(get, {Requrl, Headers}, [],  [{sync,true}]),
	result_to_terms(Result).


%%for updating a track on arclould
update_audio(URl_host,Access_secret,Access_key,Sig_version,Bucket_name,Title,Acr_id,Audio_id,Custom_fields)->
	Http_method = "PUT",
	Http_uri = lists:append(["/v1/audios/",Acr_id]),
	Timestamp = erlang:integer_to_list(calendar:datetime_to_gregorian_seconds(calendar:universal_time())-62167219200),
	Signature = create_signature(Http_method,Http_uri,Access_key,Access_secret,Sig_version,Timestamp),
	Requrl = lists:append(["https://",URl_host,Http_uri]),
	Data = [
				lists:append([edoc_lib:escape_uri("audio_id"),"=",edoc_lib:escape_uri(Audio_id)]),
				lists:append([edoc_lib:escape_uri("title"),"=",edoc_lib:escape_uri( Title)]),
				lists:append([edoc_lib:escape_uri("bucket_name"),"=",edoc_lib:escape_uri(Bucket_name)])	
			],
	[Key_accum_final,Value_accum_final] = create_custom_fields_update(Custom_fields),
	Data_send = lists:append([Data,Key_accum_final,Value_accum_final]),
	Body = string:join(Data_send,"&"),
	ContentType = "application/x-www-form-urlencoded",
	Headers = 
	[
		{"Content-length", integer_to_list(length(Body))},{"access-key",Access_key},
		{"signature-version",Sig_version},{"signature",Signature},{"timestamp",Timestamp},{"Accept","*/*"}
	],
	Result = httpc:request(put, {Requrl, Headers,ContentType, Body}, [],  [{sync,true}]),
	result_to_terms(Result).


%%for deleting audio
delete_audio(URl_host,Access_secret,Access_key,Sig_version,Acr_id)->
	Http_method = "DELETE",
	Http_uri = lists:append(["/v1/audios/",Acr_id]),
	Timestamp = erlang:integer_to_list(calendar:datetime_to_gregorian_seconds(calendar:universal_time())-62167219200),
	Signature = create_signature(Http_method,Http_uri,Access_key,Access_secret,Sig_version,Timestamp),
	Requrl = lists:append(["https://",URl_host,Http_uri]),
	Headers = [{"access-key",Access_key},{"signature-version",Sig_version},{"signature",Signature},{"timestamp",Timestamp},{"Accept","*/*"}],
	Result = httpc:request(delete, {Requrl, Headers}, [],  [{sync,true}]),
	result_to_terms(Result).



%%for creating custom fields when doing an update of an uploaded track
create_custom_fields_update(Custom_fields)->
	lists:foldl(
		fun({Key,Value},[Key_accum,Value_acccum])->  
			 New_Key_Accum = [ lists:append([edoc_lib:escape_uri("custom_key[]"),"=",edoc_lib:escape_uri(atom_to_list(Key))]) | Key_accum],
			 New_Value_Accum = [ lists:append([edoc_lib:escape_uri("custom_value[]"),"=",edoc_lib:escape_uri(Value)]) | Value_acccum],
			[New_Key_Accum,New_Value_Accum]
		end,
	[[],[]],Custom_fields).



%%for creating custom fields
create_custom_fields(Custom_fields)->
	lists:foldl(
		fun({Key,Value},[Key_accum,Value_acccum])->  
			 New_Key_Accum = [{'custom_key[]',atom_to_list(Key)}|Key_accum],
			 New_Value_Accum = [{'custom_value[]',Value}|Value_acccum],
			[New_Key_Accum,New_Value_Accum]
		end,
	[[],[]],Custom_fields).


%%for formatting form-data
format_multipart_formdata(Boundary, Fields, Files) ->
	FieldParts = 
	lists:map(
		fun({FieldName, FieldContent}) ->
		   [lists:concat(["--", Boundary]),
			lists:concat(["Content-Disposition: form-data; name=\"",atom_to_list(FieldName),"\""]),
			"",
			FieldContent]
		end, Fields),
	FieldParts2 = lists:append(FieldParts),
	FileParts = 
	lists:map(
		fun({FieldName, FileName, FileContent}) ->
			[lists:concat(["--", Boundary]),
			lists:concat(["Content-Disposition: form-data; name=\"",atom_to_list(FieldName),"\"; filename=\"",FileName,"\""]),
			"",
			FileContent]
		end, Files),
	FileParts2 = lists:append(FileParts),
	EndingParts = [lists:concat(["--", Boundary,"--"])],
	Parts = lists:append([FieldParts2,FileParts2,EndingParts]),
	Fold_part = lists:foldr(fun(X,Accum)-> [X,"\r\n"|Accum] end,[],Parts),
	erlang:list_to_binary(Fold_part).


%%for parsing request response and getting response code
result_to_terms(Result) ->
	{ok, {{_Version,Response_code, _ReasonPhrase},Headers, ResultBody}} = Result,
	io:format("~nresponse code is ~p~nHeaders are ~p~nBod is ~p",[Response_code,Headers,ResultBody]),
	{Response_code,Headers}.
